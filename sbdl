#!/bin/zsh
# shellcheck shell=bash

# sbdl 0.5.1
# download Superbacked & auxiliary files
# shell script for LaunchAgent

export LANG=en_US.UTF-8
export PATH=/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin:/usr/local/sbin:/opt/homebrew/bin:/opt/homebrew/sbin:/opt/local/bin:/opt/local/sbin:"$HOME"/.local/bin:"$HOME"/.local/sbin

sbdlversion="0.5.1"
uiprocess="Superbacked Downloader"
process="sbdl"
account=$(id -u)
accountname=$(id -un)
appdlurl1="https://superbacked.com/api/downloads/superbacked-"
wherefromurl="https://superbacked.com/api/downloads/superbacked-std-latest.dmg"
wherefromurl_linux="https://superbacked.com/api/downloads/superbacked-std-latest.AppImage"
appdlurl2="-latest.dmg?license="
appdlurl3="-latest.AppImage?license="
gitdlurl="https://raw.githubusercontent.com/superbacked/superbacked/main/releases/v"
relurl="https://github.com/superbacked/superbacked/tree/main/releases"
devgpg="Primary key fingerprint: E786 274B C92B 47C2 3C1C  F44B 8C9C A674 C47C A060"
devskid="0A3997912C165C0C15E2BBF4FB7BEB8D69B186E2"

logloc="$HOME/Library/Logs/local.$accountname.$process.log"
exec > >(tee -a "$logloc") 2>&1

# for testing only
override=false
if [[ $1 == "--override" ]] ; then
	override=true
fi

# create configuration file/directory
configdir="$HOME/Library/Application Support/SuperbackedDownloader"
! [[ -d "$configdir" ]] && mkdir -p "$configdir" 2>/dev/null
configloc="$configdir/sbdl.cfg"
! [[ -f "$configloc" ]] && echo -e "# Mandatory: please enter your personal software license key\nLicense: <yourLicenseKey>\n# Optional: enter the full path to your preferred download folder\nDownloadPath: \n# Optional: replace with '1', 'y', 'yes', 'Y', 'YES' or 'Yes' for additional Linux AppImage download\nLinuxDownload: no\n# Optional: release label can be set to 'op' (special operator release for law firms)\nReleaseLabel: " > "$configloc" 2>/dev/null

# function: error beep
_beep () {
	osascript -e 'beep' -e 'delay 0.5' &>/dev/null
}

# function: success sound
_success () {
	afplay "/System/Library/Components/CoreAudio.component/Contents/SharedSupport/SystemSounds/system/burn complete.aif" &>/dev/null
}

# function: info sound
_info () {
	afplay "/System/Library/Components/CoreAudio.component/Contents/SharedSupport/SystemSounds/system/screen_sharing_started.caf" &>/dev/null
}

# function: notify user
_notify () {
	osascript &>/dev/null << EOT
tell application "System Events"
	display notification "$2" with title "$uiprocess [" & "$account" & "]" subtitle "$1"
end tell
EOT
}

# function: check for initial redirect
_redirect () {
	mainurl="$1"
	if ! [[ $(curl -sI --connect-timeout 10 "$mainurl" 2>/dev/null | grep -i "^location: " | tail -n 1 | awk -F"ocation: " '{print $NF}') ]] ; then
		return 0
	else
		return 1
	fi
}

currentdate=$(date)
echo -e "\n*** $uiprocess ($process $sbdlversion) launched: $currentdate ***"

# configuration
config=$(cat "$configloc" 2>/dev/null)
if ! [[ $config ]] ; then
	echo "ERROR: configuration is empty!"
	_notify "❌ Error: configuration!" "Configuration is empty"
	_beep
	exit 1
fi
echo "INFO: configuration imported from $configloc"

# check configuration for software license key
license=$(echo "$config" | grep "^License:" | awk -F":" '{print $2}' | xargs | sed -e 's/^ *//' -e 's/ *$//')
if ! [[ $license ]] || echo "$license" | grep "yourLicenseKey" &>/dev/null ; then
	echo -e "NOTE: no software license key detected in configuration!\nNOTE: please edit configuration manually"
	_notify "ℹ️ Software license key missing" "Please edit configuration manually"
	_info
	exit
fi
echo "INFO: software license key detected in configuration"

# check configuration for software release label (default to std)
label=$(echo "$config" | grep "^ReleaseLabel:" | awk -F":" '{print $2}' | xargs | sed -e 's/^ *//' -e 's/ *$//')
if ! [[ $label ]] ; then
	label="std"
	bundleid="com.superbacked.$label"
	echo "INFO: auto-set to std release ($bundleid)"
else
	bundleid="com.superbacked.$label"
	echo "INFO: set to $label release ($bundleid)"
fi
finalappdlurl="$appdlurl1$label$appdlurl2$license"

# read remote version number
if ! _redirect "$relurl" ; then
	echo "ERROR: redirect in place at $relurl"
	_notify "❌ Error: redirect!" "$relurl"
	_beep
	exit 1
else
	versionfound=false
	if command -v lynx &>/dev/null ; then
		version=$(lynx -dump "$relurl" 2>/dev/null | grep "\. $relurl/v" | awk -F"/v" '{print $NF}' | sort -rV | head -n 1 | xargs)
		[[ $version ]] && versionfound=true
	else
		echo "NOTE: lynx is not installed! Using cURL as fallback..."
	fi
	if ! $versionfound ; then
		version=$(curl -s --connect-timeout 10 "$relurl" | grep "href=\"/superbacked/superbacked/tree/main/releases/" | rev | awk -F"[<>]" '{print $5}' | rev | sed 's/^v//' | sort -rV | head -n 1 | xargs)
	fi
	if ! [[ $version ]] ; then
		echo "ERROR: new version information missing!"
		_notify "❌ Error: new version!" "Information missing"
		_beep
		exit 1
	fi
fi

# search for installed Superbacked app
apploc=$(mdfind "kMDItemCFBundleIdentifier == '""$bundleid""'" 2>/dev/null | awk 'NR==1')
if ! [[ $apploc ]] ; then
	echo -e "NOTE: Superbacked not installed yet!\nRemote version: $version"
else
	echo "INFO: software installed at $apploc"
	# read local version numbers
	plistloc="$apploc/Contents/Info.plist"
	localversion=$(defaults read "$plistloc" CFBundleVersion 2>/dev/null)
	if ! [[ $localversion ]] ; then
		echo "ERROR: unable to read local version number"
		_notify "⚠️ Error: version number!" "Unable to read local version number"
		_beep
		exit 1
	fi
	
	# for testing only
	if $override ; then
		localversion="1.0.0"
	fi
	
	echo -e "Installed version: $localversion\nRemote version: $version"

	# compare version numbers
	newestversion=$(echo -e "$version\n$localversion" | sort -rV | head -n 1)
	echo "Newest version: $newestversion"
	if [[ $localversion == "$newestversion" ]] ; then
		echo "Newest version already installed: exiting..."
		exit
	else
		echo "Newer version available: downloading..."
		_notify "ℹ️ Newer version available" "$version <- $localversion"
		_info
	fi
fi

# determine download path
dlpath=$(echo "$config" | grep "^DownloadPath:" | awk -F":" '{print $2}' | xargs | sed -e 's/^ *//' -e 's/ *$//')
if ! [[ $dlpath ]] || ! [[ -d "$dlpath" ]] ; then
	dlpath="$HOME/Downloads"
	echo "INFO: using default target folder $dlpath"
else
	echo "INFO: using target folder $dlpath"
fi

# check configuration for Linux download
linuxinfo=$(echo "$config" | grep "^LinuxDownload:" | awk -F":" '{print $2}' | xargs | sed -e 's/^ *//' -e 's/ *$//')
if [[ $linuxinfo =~ ^(1|y|Y|yes|YES|Yes)$ ]] ; then
	linuxdl=true
	echo "INFO: Linux AppImage download enabled"
	finalappdlurl_linux="$appdlurl1$label$appdlurl3$license"
else
	linuxdl=false
	echo "INFO: Linux AppImage download disabled"
fi

# download auxiliary files from GitHub first
sleep 1
echo "Downloading auxiliary files from GitHub..."
errors=false
cd "$dlpath"

# GPG signature file
if ! _redirect "$gpgdlurl" ; then
	echo "ERROR: redirect in place at $gpgdlurl"
	_notify "❌ Error: redirect!" "$gpgdlurl"
	_beep
	exit 1
fi
gpgdownloaded=false
rm -f ./"SHA256SUMS.asc" 2>/dev/null
gpgdlurl="$gitdlurl$version/SHA256SUMS.asc"
echo "Download URL: $gpgdlurl"
if ! curl -s --connect-timeout 10 --xattr -o ./SHA256SUMS.asc "$gpgdlurl" 2>/dev/null ; then
	echo "ERROR: downloading SHA256SUMS.asc!"
	_notify "❌ Download error!" "SHA256SUMS.asc"
	_beep
	errors=true
else
	curlxa=$(xattr -p user.xdg.origin.url ./SHA256SUMS.asc 2>/dev/null)
	if [[ $curlxa == "$gpgdlurl" ]] ; then
		echo "SUCCESS: downloaded SHA256SUMS.asc"
		_notify "☑️ Download successful" "SHA256SUMS.asc"
		gpgdownloaded=true
		hexdate=$(echo "obase=16; $(date +%s)" | bc | tr '[:upper:]' '[:lower:]')
		qxattr="0081;$hexdate;sbdl;"
		if xattr -w com.apple.quarantine "$qxattr" ./SHA256SUMS.asc &>/dev/null ; then
			echo "SUCCESS: added XA $qxattr to SHA256SUMS.asc"
		else
			echo "ERROR: unable to add XA $qxattr to SHA256SUMS.asc"
		fi
	else
		rm -f ./"SHA256SUMS.asc" 2>/dev/null
		echo "ERROR: SHA256SUMS.asc download was redirected!"
		_notify "❌ Error: download redirected!" "SHA256SUMS.asc"
		_beep
		errors=true
	fi
fi
sleep 1

# sha256 checksums file
if ! _redirect "$shadlurl" ; then
	echo "ERROR: redirect in place at $shadlurl"
	_notify "❌ Error: redirect!" "$shadlurl"
	_beep
	exit 1
fi
shasumdownloaded=false
rm -f ./"SHA256SUMS" 2>/dev/null
shadlurl="$gitdlurl$version/SHA256SUMS"
echo "Download URL: $shadlurl"
if ! curl -s --connect-timeout 10 --xattr -o ./SHA256SUMS "$shadlurl" 2>/dev/null ; then
	echo "ERROR: downloading SHA256SUMS!"
	_notify "❌ Download error!" "SHA256SUMS"
	_beep
	errors=true
else
	curlxa=$(xattr -p user.xdg.origin.url ./SHA256SUMS 2>/dev/null)
	if [[ $curlxa == "$shadlurl" ]] ; then
		echo "SUCCESS: downloaded SHA256SUMS"
		shasumdownloaded=true
		hexdate=$(echo "obase=16; $(date +%s)" | bc | tr '[:upper:]' '[:lower:]')
		qxattr="0081;$hexdate;sbdl;"
		if xattr -w com.apple.quarantine "$qxattr" ./SHA256SUMS &>/dev/null ; then
			echo "SUCCESS: added XA $qxattr to SHA256SUMS"
		else
			echo "ERROR: unable to add XA $qxattr to SHA256SUMS"
		fi
	else
		rm -f ./"SHA256SUMS" 2>/dev/null
		echo "ERROR: SHA256SUMS download was redirected!"
		_notify "❌ Error: download redirected!" "SHA256SUMS"
		_beep
		errors=true
	fi
fi

# verify sha256 checksums file
gpgverified=false
if $shasumdownloaded ; then
	if $gpgdownloaded ; then
		if command -v gpg &>/dev/null ; then
			gpgout=$(gpg --verify ./SHA256SUMS.asc 2>&1)
			if echo "$gpgout" | grep "^gpg: Good signature " &>/dev/null && echo "$gpgout" | grep "^$devgpg$" &>/dev/null ; then
				gpgverified=true
				echo "SUCCESS: verified SHA256SUMS (GPG)"
				_notify "☑️ Download verified" "GPG: SHA256SUMS"
			else
				echo "ERROR: GPG verification failed!"
				_notify "❌ Verification failed!" "GPG: SHA256SUMS"
				_beep
				errors=true
				chmod -x ./SHA256SUMS ./SHA256SUMS.asc 2>/dev/null
			fi
		else
			echo "WARNING: GPG not installed - unable to verify!"
			_notify "⚠️ GPG not installed!" "Unable to verify SHA256SUMS"
			_beep
			errors=true
			chmod -x ./SHA256SUMS
			sleep 1
		fi
	else
		echo "WARNING: unable to verify due to SHA256SUMS.asc download error!"
		errors=true
		sleep 1
	fi
else
	echo "WARNING: unable to verify due to SHA256SUMS download error!"
	errors=true
	sleep 1
fi

# release notes file
if ! _redirect "$rndlurl" ; then
	echo "ERROR: redirect in place at $rndlurl"
	_notify "❌ Error: redirect!" "$rndlurl"
	_beep
	exit 1
fi
rndownloaded=false
rnfilename="superbacked-$label-$version-release-notes.txt"
rm -f ./"$rnfilename" 2>/dev/null
rndlurl="$gitdlurl$version/$rnfilename"
echo "Download URL: $rndlurl"
if ! curl -s --connect-timeout 10 --xattr -o ./"$rnfilename" "$rndlurl" 2>/dev/null ; then
	echo "ERROR: downloading release notes!"
	_notify "❌ Download error!" "$rnfilename"
	_beep
	errors=true
else
	curlxa=$(xattr -p user.xdg.origin.url ./"$rnfilename" 2>/dev/null)
	if [[ $curlxa == "$rndlurl" ]] ; then
		rndownloaded=true
		echo "SUCCESS: downloaded $rnfilename"
		hexdate=$(echo "obase=16; $(date +%s)" | bc | tr '[:upper:]' '[:lower:]')
		qxattr="0081;$hexdate;sbdl;"
		if xattr -w com.apple.quarantine "$qxattr" ./"$rnfilename" &>/dev/null ; then
			echo "SUCCESS: added XA $qxattr to $rnfilename"
		else
			echo "ERROR: unable to add XA $qxattr to $rnfilename"
		fi
		if $shasumdownloaded ; then
			if shasum -a 256 -c --ignore-missing SHA256SUMS 2>/dev/null | grep "\-release\-notes\.txt: OK$" &>/dev/null ; then
				if $gpgverified ; then
					echo "SUCCESS: verified $rnfilename (shasum)"
					_notify "☑️ Download verified" "shasum: $rnfilename"
				else
					echo "WARNING: insecure verification (shasum without GPG)"
					_notify "⚠️ Insecure download verification!" "GPG: $rnfilename"
					_beep
					errors=true
				fi
			else
				echo "ERROR: $rnfilename verification failed (shasum)!"
				_notify "❌ Verification failed!" "shasum: $rnfilename"
				_beep
				errors=true
				chmod -x ./"$rnfilename" 2>/dev/null
			fi
		else
			echo -e "SUCCESS downloaded $rnfilename\nWARNING: unable to verify with shasum due to SHA256SUMS download error"
			_notify "⚠️ Unverified download!" "shasum: $rnfilename"
			_beep
			errors=true
		fi
	else
		rm -f ./"$rnfilename" 2>/dev/null
		echo "ERROR: $rnfilename download was redirected!"
		_notify "❌ Error: download redirected!" "$rnfilename"
		_beep
		errors=true
	fi
fi

# download main application DMG
appcheck=true
dmgcheck=true
filename=$(curl -sI --connect-timeout 10 "$finalappdlurl" 2>&1 | grep "filename=" | awk -F"filename=" '{print $2}' | xargs | tr -cd '\40-\176')
! [[ $filename ]] && filename="superbacked-$label-$version.dmg"
if [[ -f ./"$filename" ]] ; then
	echo "NOTE: $filename already exists at download path - checking..."
	if $shasumdownloaded ; then
		if shasum -a 256 -c --ignore-missing ./SHA256SUMS 2>&1 | grep "\.dmg: OK$" &>/dev/null ; then
			if $gpgverified ; then
				echo "INFO: DMG file OK (shasum)"
				_notify "✅ File exists & verified" "$filename"
				_info
				dmgdl=false
			else
				echo -e "INFO: DMG file OK (shasum)\nWARNING: insecure verification (shasum without GPG)"
				_notify "⚠️ File exists | insecure!" "GPG: $filename"
				_beep
				dmgdl=false
				errors=true
				chmod -x ./"$filename" 2>/dev/null
			fi
		else
			echo "NOTE: DMG file corrupted or out-of-date (shasum) - will unlink..."
			dmgdl=true
		fi
	else
		if hdiutil verify ./"$filename" &>/dev/null ; then
			echo -e "INFO: DMG file OK (hdiutil)\nWARNING: insecure (without any verification)!"
			_notify "⚠️ File exists intact | unable to verify" "$filename"
			_beep
			dmgdl=false
			dmgcheck=false
			errors=true
			chmod -x ./"$filename" 2>/dev/null
		else
			echo "NOTE: DMG file corrupted (hdiutil) - will unlink..."
			dmgdl=true
		fi
	fi
else
	dmgdl=true
	sleep 1
fi
if $dmgdl ; then
	if ! _redirect "$finalappdlurl" ; then
		echo "ERROR: redirect in place at $finalappdlurl"
		_notify "❌ Error: redirect!" "$finalappdlurl"
		_beep
		exit 1
	fi
	_notify "⏳ Please wait: downloading…" "$filename" &
	echo "Downloading: $filename"
	rm -f ./"$filename" 2>/dev/null
	echo "Download URL: $wherefromurl"
	if ! curl -s --connect-timeout 10 --xattr -o ./"$filename" "$finalappdlurl" 2>/dev/null ; then
		echo "ERROR: download failed!"
		_notify "❌ Error: download!" "$filename"
		_beep
		errors=true
		dmgcheck=false
		appcheck=false
	else
		curlxa=$(xattr -p user.xdg.origin.url ./"$filename" 2>/dev/null | awk -F"?" '{print $1}')
		if [[ $curlxa == "$wherefromurl" ]] ; then
			echo "SUCCESS: downloaded $filename"
			if xattr -w user.xdg.origin.url "$wherefromurl?license=<redacted>" ./"$filename" &>/dev/null ; then
				echo "SUCCESS: obscured software license code in XA user.xdg.origin.url"
			else
				echo "ERROR: failed to obscure software license code in XA user.xdg.origin.url"
				if xattr -d user.xdg.origin.url ./"$filename" &>/dev/null ; then
					echo "NOTE: deleted XA user.xdg.origin.url instead"
				else
					echo "ERROR: failed to delete XA user.xdg.origin.url!"
				fi
			fi
			hexdate=$(echo "obase=16; $(date +%s)" | bc | tr '[:upper:]' '[:lower:]')
			qxattr="0081;$hexdate;sbdl;"
			if xattr -w com.apple.quarantine "$qxattr" ./"$filename" &>/dev/null ; then
				echo "SUCCESS: added XA $qxattr to $filename"
			else
				echo "ERROR: unable to add XA $qxattr to $filename"
			fi
			if shasum -a 256 -c --ignore-missing ./SHA256SUMS 2>&1 | grep "\.dmg: OK$" &>/dev/null ; then
				if $gpgverified ; then
					echo "SUCCESS: $filename verified (shasum)"
					_notify "✅ Downloaded & verified" "Superbacked v$version (macOS)"
					_success
				else
					echo -e "SUCCESS: $filename verified (shasum)\nWARNING: insecure verification (shasum without GPG)!"
					_notify "⚠️ Downloaded & verified | insecure" "GPG: $filename"
					_beep
					errors=true
					chmod -x ./"$filename" 2>/dev/null
				fi
				appcheck=true
			else
				echo "ERROR: $filename verification failed (shasum)!"
				_notify "❌ Download: verification failed!" "shasum: $filename"
				_beep
				errors=true
				chmod -x ./"$filename" 2>/dev/null
			fi
		else
			rm -f ./"$filename" 2>/dev/null
			echo "ERROR: $filename download was redirected!"
			_notify "❌ Error: download redirected!" "$filename"
			_beep
			errors=true
		fi
	fi
fi

# check DMG with hdiutil
if $dmgcheck ; then
	sleep 1
	echo "Verifying DMG internal checksum with hdiutil..."
	if hdiutil verify ./"$filename" &>/dev/null ; then
		echo "SUCCESS: DMG internal checksum verified (hdiutil)"
		_notify "✅ Internal checksum verified" "hdiutil: $filename"
	else
		echo -e "ERROR: DMG internal checksum failed (hdiutil)!\nNOTE: skipping application verification"
		_notify "❌ Internal checksum failed!" "hdiutil: $filename"
		_beep
		errors=true
		appcheck=false
	fi
fi

# mount DMG volume & check app
if $appcheck ; then
	sleep 1
	mountraw=$(hdiutil attach -nobrowse ./"$filename" 2>&1 | grep "^/dev/")
	sleep 1
	echo "Verifying Superbacked application..."
	_notify "⏳ Please wait: verifying…" "Superbacked application" &
	appcheckerror=false
	verifyinfo="Errors:"
	volume=$(echo "$mountraw" | tail -n 1 | awk '{print substr($0, index($0,$3))}')
	device=$(echo "$mountraw" | tail -n 1 | awk '{print $1}')
	parentdevice=$(echo "$mountraw" | head -n 1 | awk '{print $1}')
	csraw=$(codesign --verify --deep --strict --verbose=4 "$volume/Superbacked.app" 2>&1 | grep -v -e "^\-\-prepared" -e "^\-\-validated" -e "^In subcomponent:" -e "^In architecture:")
	if ! echo "$csraw" | grep "valid on disk$" &>/dev/null || ! echo "$csraw" | grep "satisfies its Designated Requirement$" &>/dev/null ; then
		echo "INVALID: application bundle integrity!"
		appcheckerror=true
		if [[ $verifyinfo == "Errors:" ]] ; then
			verifyinfo="$verifyinfo invalid"
		else
			verifyinfo="$verifyinfo | invalid"
		fi
	else
		echo "VALID: application bundle integrity"
	fi
	if echo "$csraw" | grep "^file missing:" &>/dev/null ; then
		echo "ERROR: file(s) missing from application bundle!"
		appcheckerror=true
		if [[ $verifyinfo == "Errors:" ]] ; then
			verifyinfo="$verifyinfo missing files"
		else
			verifyinfo="$verifyinfo | missing files"
		fi
	else
		echo "INFO: no missing files"
	fi
	if echo "$csraw" | grep "^file added:" &>/dev/null ; then
		echo "ERROR: file(s) added to application bundle!"
		appcheckerror=true
		if [[ $verifyinfo == "Errors:" ]] ; then
			verifyinfo="$verifyinfo added files"
		else
			verifyinfo="$verifyinfo | added files"
		fi
	else
		echo "INFO: no added files"
	fi
	if echo "$csraw" | grep "^file modified:" &>/dev/null ; then
		echo "ERROR: file(s) in application bundle modified!"
		appcheckerror=true
		if [[ $verifyinfo == "Errors:" ]] ; then
			verifyinfo="$verifyinfo modified"
		else
			verifyinfo="$verifyinfo | modified"
		fi
	else
		echo "INFO: no modified files"
	fi
	spctlraw=$(spctl -a -vvv -t install "$volume/Superbacked.app" 2>&1)
	if ! echo "$spctlraw" | grep "\.app: accepted$" &>/dev/null ; then
		echo "ERROR: application not accepted by macOS Gatekeeper"
		appcheckerror=true
		if [[ $verifyinfo == "Errors:" ]] ; then
			verifyinfo="$verifyinfo Gatekeeper"
		else
			verifyinfo="$verifyinfo | Gatekeeper"
		fi
	else
		echo "ACCEPTED: macOS Gatekeeper"
	fi
	if ! echo "$spctlraw" | grep "^source=Notarized Developer ID$" &>/dev/null ; then
		echo "ERROR: application not notarized!"
		appcheckerror=true
		if [[ $verifyinfo == "Errors:" ]] ; then
			verifyinfo="$verifyinfo unnotarized"
		else
			verifyinfo="$verifyinfo | unnotarized"
		fi
	else
		echo "INFO: signed & notarized"
	fi
	xcraw=$(xcrun stapler validate "$volume/Superbacked.app" 2>&1)
	if ! echo "$xcraw" | grep "^The validate action worked!$" &>/dev/null ; then
		echo "ERROR: application not properly stapled!"
		appcheckerror=true
		if [[ $verifyinfo == "Errors:" ]] ; then
			verifyinfo="$verifyinfo unstapled"
		else
			verifyinfo="$verifyinfo | unstapled"
		fi
	else
		echo "INFO: properly stapled"
	fi
	rm -f /tmp/codesign0 /tmp/codesign1 /tmp/codesign2 &>/dev/null
	cd /tmp
	codesign -dvvvv --requirements - --entitlements - --extract-certificates "$volume/Superbacked.app" &>/dev/null
	sleep .5
	cd "$dlpath"
	certraw=$(security verify-cert -c /tmp/codesign0 2>&1)
	if [[ $certraw != "...certificate verification successful." ]] ; then
		echo "ERROR (certificate): $certraw"
		appcheckerror=true
		skid=$(openssl x509 -in /tmp/codesign0 -inform DER -noout -text -fingerprint | grep -A1 "Subject Key Identifier" | tail -1 | xargs | sed s/://g)
		if [[ $skid != "$devskid" ]] ; then
			echo "NOTE: certificate SKID has changed!"
			if [[ $verifyinfo == "Errors:" ]] ; then
				verifyinfo="$verifyinfo SKID change | $certraw"
			else
				verifyinfo="$verifyinfo | SKID change | $certraw"
			fi
		else
			if [[ $verifyinfo == "Errors:" ]] ; then
				verifyinfo="$verifyinfo $certraw"
			else
				verifyinfo="$verifyinfo | $certraw"
			fi
		fi
	else
		echo "VERIFIED: code-signing certificate"
	fi
	rm -f /tmp/codesign0 /tmp/codesign1 /tmp/codesign2 &>/dev/null
	hdiutil unmount -force "$volume" &>/dev/null
	sleep .3
	hdiutil detach -force "$device" &>/dev/null
	sleep .3
	hdiutil detach -force "$parentdevice" &>/dev/null
	if ! $appcheckerror ; then
		echo "SUCCESS: application bundle OK"
		_notify "✅ Application verified" "Superbacked.app"
		_success
	else
		errors=true
		echo "ERROR: application bundle has been corrupted!"
		_notify "❌ Superbacked.app corrupted!" "$verifyinfo"
		_success
	fi
fi

if ! $linuxdl ; then
	if $errors ; then
		echo "NOTE: there were errors!"
		open -a Console.app "$logloc" &>/dev/null
		exit 1
	else
		echo "INFO: executed without errors"
		if $rndownloaded ; then
			qlmanage -p "$dlpath/$rnfilename" &>/dev/null
		fi
		exit
	fi
fi

# download main application (AppImage/Linux)
filename_linux=$(curl -sI --connect-timeout 10 "$finalappdlurl_linux" 2>&1 | grep "filename=" | awk -F"filename=" '{print $2}' | xargs | tr -cd '\40-\176')
! [[ $filename_linux ]] && filename_linux="superbacked-$label-$version.AppImage"
aidl=true
if [[ -f ./"$filename_linux" ]] ; then
	echo "NOTE: $filename_linux already exists at download path - checking..."
	if $shasumdownloaded ; then
		if shasum -a 256 -c --ignore-missing ./SHA256SUMS 2>&1 | grep "\.AppImage: OK$" &>/dev/null ; then
			if $gpgverified ; then
				echo "INFO: AppImage file OK (shasum)"
				_notify "✅ File exists & verified" "$filename_linux"
				_info
				aidl=false
			else
				echo -e "INFO: AppImage file OK (shasum)\nWARNING: insecure verification (shasum without GPG)"
				_notify "⚠️ File exists | insecure!" "GPG: $filename_linux"
				_beep
				aidl=false
				errors=true
				chmod -x ./"$filename_linux" 2>/dev/null
			fi
		else
			echo "NOTE: AppImage file corrupted or out-of-date (shasum) - will unlink..."
		fi
	else
		if ! command -v 7z &>/dev/null ; then
			echo -e "NOTE: 7z is not installed!\nWARNING: unable to verify or check integrity!"
			_notify "❌ File exists | unable to verify" "$filename_linux"
			_beep
			aidl=false
			errors=true
			chmod -x ./"$filename_linux" 2>/dev/null
		else
			if 7z t ./"$filename_linux" 2>&1 | grep "^Can not open the file as archive$" &>/dev/null ; then
				echo "NOTE: AppImage file corrupted (7z) - will unlink..."
			else
				echo -e "INFO: AppImage file OK (7z)\nWARNING: insecure (without verification)!"
				_notify "⚠️ File exists intact | unable to verify" "$filename_linux"
				_beep
				aidl=false
				errors=true
				chmod -x ./"$filename_linux" 2>/dev/null
			fi
		fi
	fi
fi
if $aidl ; then
	if ! _redirect "$finalappdlurl_linux" ; then
		echo "ERROR: redirect in place at $finalappdlurl_linux"
		_notify "❌ Error: redirect!" "$finalappdlurl_linux"
		_beep
		exit 1
	fi
	_notify "⏳ Please wait: downloading…" "$filename_linux" &
	echo "Downloading: $filename_linux"
	rm -f ./"$filename_linux" 2>/dev/null
	echo "Download URL: $wherefromurl_linux"
	if ! curl -s --connect-timeout 10 --xattr -o ./"$filename_linux" "$finalappdlurl_linux" 2>/dev/null ; then
		echo "ERROR: download failed!"
		_notify "❌ Error: download!" "$filename_linux"
		_beep
		errors=true
	else
		curlxa=$(xattr -p user.xdg.origin.url ./"$filename_linux" 2>/dev/null | awk -F"?" '{print $1}')
		if [[ $curlxa == "$wherefromurl_linux" ]] ; then
			echo "SUCCESS: downloaded $filename_linux"
			if xattr -w user.xdg.origin.url "$wherefromurl_linux?license=<redacted>" ./"$filename_linux" &>/dev/null ; then
				echo "SUCCESS: obscured software license code in XA user.xdg.origin.url"
			else
				echo "ERROR: failed to obscure software license code in XA user.xdg.origin.url"
				if xattr -d user.xdg.origin.url ./"$filename_linux" &>/dev/null ; then
					echo "NOTE: deleted XA user.xdg.origin.url instead"
				else
					echo "ERROR: failed to delete XA user.xdg.origin.url!"
				fi
			fi
			echo "INFO: skipping addition of XA com.apple.quarantine (AppImage)"
			if shasum -a 256 -c --ignore-missing ./SHA256SUMS 2>&1 | grep "\.AppImage: OK$" &>/dev/null ; then
				if $gpgverified ; then
					echo "SUCCESS: $filename_linux verified (shasum)"
					_notify "✅ Downloaded & verified" "Superbacked v$version (Linux)"
					_success
				else
					echo -e "SUCCESS: $filename_linux verified (shasum)\nWARNING: insecure verification (shasum without GPG)!"
					_notify "⚠️ Downloaded & verified | insecure" "GPG: $filename_linux"
					_beep
					errors=true
					chmod -x ./"$filename_linux" 2>/dev/null
				fi
			else
				echo "ERROR: $filename_linux verification failed (shasum)!"
				_notify "❌ Download: verification failed!" "shasum: $filename_linux"
				_beep
				errors=true
				chmod -x ./"$filename_linux" 2>/dev/null
			fi
		else
			rm -f ./"$filename_linux" 2>/dev/null
			echo "ERROR: $filename_linux download was redirected!"
			_notify "❌ Error: download redirected!" "$filename_linux"
			_beep
			errors=true
		fi
	fi
fi

if $errors ; then
	echo "NOTE: there were errors!"
	open -a Console.app "$logloc" &>/dev/null
	exit 1
else
	echo "INFO: executed without errors"
	if $rndownloaded ; then
		qlmanage -p "$dlpath/$rnfilename" &>/dev/null
	fi
	exit
fi

